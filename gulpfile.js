var async = require('async');
var fs = require('fs-extra');
var path = require('path');
var exec = require('child_process').exec;
var gulp = require('gulp');
var gutil = require('gulp-util');
var install = require('gulp-install');
var jshint = require('gulp-jshint');
var less = require('gulp-less');
var mocha = require('gulp-spawn-mocha');
var runSequence = require('run-sequence');
var spawn = require('child_process').spawn;
var svn = require('svn-interface');

gulp.task('default', ['build', 'test']);

gulp.task('build', ['build-less', 'build-version', 'install-example-modules']);

gulp.task('build-less', function() {
  return gulp.src('client/less/style.less')
    .pipe(less())
    .pipe(gulp.dest('client/www/style'));
});

gulp.task('build-version', function(callback) {
  var pkg = require('./package.json');
  var content =
    '// This file is generated by `gulp build`. Do not edit manually!' +
    '\ndocument.querySelector(".header-version").innerHTML = ' +
    JSON.stringify('Studio v' + pkg.version) + ';' +
    '\n';

  var filepath = path.resolve(__dirname,
    'client', 'www', 'scripts', 'version.js');

  fs.writeFile(filepath, content, 'utf-8', callback);
});

gulp.task('install-example-modules', function() {
  return gulp.src('examples/*/package.json')
    .pipe(install({ production: true }));
});

// alias for sl-ci-run and `npm test`
gulp.task('mocha-and-karma', ['test']);

gulp.task('test', ['build'], function(callback) {
  runSequence(
    'jshint',
    'test-server',
    'test-client-integration',
    callback);
});

gulp.task('jshint', function() {
  return gulp.src([
    'server/**/*.js',
    'client/test/**/*.js',
    'devtools/server/**/*.js',
    // TODO(bajtos) add more files once they pass the linter
    '!client/test/integration/{sandbox/,sandbox/**}'
  ])
    .pipe(jshint())
    .pipe(jshint.reporter('jshint-stylish'))
    .pipe(jshint.reporter('fail'));
});

gulp.task('test-server', function() {
  return gulp.src('server/test/*.js', { read: false })
    .pipe(mocha());
});

gulp.task('test-client-integration', function(callback) {
  var child = spawn(
    process.execPath,
    [
      'client/test/integration/test-server',
      'node_modules/.bin/karma',
      'start',
      '--single-run',
      '--browsers',
      'PhantomJS',
      'client/test/integration/karma.integration.js',
    ],
    {
      cwd: __dirname,
      stdio: 'inherit'
    });

  child.on('error', function(err) {
    callback(err);
  });
  child.on('exit', function(code) {
    if (code)
      callback(new Error('Failed with exit code ' + code));
    else
      callback();
  });
});

gulp.task('pull-devtools', function(callback) {
  var REPO_URL = 'http://src.chromium.org/blink/branches/chromium';
  var DEVTOOLS_DIR = path.resolve(__dirname, 'devtools');
  var FRONTEND_DIR = path.resolve(DEVTOOLS_DIR, 'frontend');
  var PROTOCOL_FILE = path.resolve(DEVTOOLS_DIR, 'protocol.json');

  var latestBranch;

  async.series([
    removeOldFiles,
    fetchBranchFiles,
    writeVersionFile,
    generateProtocolCommands,
  ], function(err) {
    callback(err);
  });

  function fetchLatestBranchId(cb) {
    svn.list(REPO_URL, function(err, result) {
      if (err) return callback(err);
      var branches = result.lists.list.entry
        // get the branch id (number)
        .map(function(e) { return +e.name._text; })
        // filter out non-numbers
        .filter(function(n) { return n; });

      latestBranch = Math.max.apply(Math, branches);
      gutil.log('Using branch', gutil.colors.yellow(latestBranch))
      cb();
    });
  }

  function removeOldFiles(cb) {
    fs.remove(FRONTEND_DIR, function(err) {
      if (err) cb(err);
      fs.remove(PROTOCOL_FILE, cb);
    });
  }

  function fetchBranchFiles(cb) {
    var branchUrl = REPO_URL + '/' + latestBranch;
    var devtoolsUrl = branchUrl + '/Source/devtools';

    gutil.log('Pulling front_end files...');
    svn.export(
      [devtoolsUrl + '/front_end', FRONTEND_DIR],
      function(err, result) {
        if (err) return cb(new Error('SVN failed: ' + result));
        gutil.log('Pulling protocol.json');
        svn.export(
          [devtoolsUrl + '/protocol.json', DEVTOOLS_DIR],
          function(err, result) {
            if (err) return cb(new Error('SVN failed: ' + result));
            cb();
          });
      });
  }

  function writeVersionFile(cb) {
    gutil.log('Writing version file');
    fs.writeFile(
      path.resolve(FRONTEND_DIR, 'version.txt'),
      'Branch: ' + latestBranch + '\nRepository: ' + REPO_URL,
      'utf-8',
      cb);
  }

  function generateProtocolCommands(cb) {
    gutil.log('Generating InspectorBackendCommands.js');
    var vm = require('vm');
    fs.readJsonFile(PROTOCOL_FILE, function(err, protocol) {
      if (err) return cb(err);

      function evalFile(filePath) {
        filePath = path.resolve(FRONTEND_DIR, filePath);
        var source = fs.readFileSync(filePath, 'utf8');
        vm.runInThisContext(source, filePath);
      }

      // TODO(bajtos) Evaluate all scripts in a new context
      /*global self:true, WebInspector:true, window:true */
      self = {};
      WebInspector = {};
      window = global;

      // TODO(bajtos) Rework to async code(?)
      try {
        evalFile('common/object.js');
        evalFile('common/utilities.js');
        evalFile('sdk/InspectorBackend.js');
      } catch(err) {
        return cb(err);
      }

      /*global InspectorBackendClass */
      var commands = InspectorBackendClass._generateCommands(protocol);
      var header = '// Auto-generated.\n' +
        '// Run `gulp pull-devtools` to update.\n' +
        '\n';

      fs.writeFile(
        path.resolve(FRONTEND_DIR, 'InspectorBackendCommands.js'),
        header + commands,
        'utf8',
        cb);
    });
  }
});
